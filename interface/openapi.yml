openapi: 3.0.3
info:
  title: ECG Orchestrator API
  version: 1.0.0
  description: |
    This service mediates device enrollment (pairing) and login-time challenges between
    Keycloak and mobile clients. It stores minimal state (e.g., short-lived challenges in Redis)
    and the public material needed to verify device-signed assertions. Sensitive identity data
    should remain in Keycloak via a custom credential (`ecg-push`).

servers:
  - url: https://orchestrator.example.com
    description: Production
  - url: https://staging.orchestrator.example.com
    description: Staging

security:
  - { }

tags:
  - name: Pairing
    description: Register a mobile device to a Keycloak user using a one-time pairing token.
  - name: Challenge
    description: Create, complete, and poll ECG authentication challenges.
  - name: Admin
    description: Device maintenance operations (optional).
  - name: Health
    description: Liveness and readiness.

paths:
  /pair/exchange/init:
    post:
      tags: [ Pairing ]
      summary: Begin device pairing using a one-time pairing JWT from Keycloak.
      description: |
        The mobile app calls this with a short-lived pairing token obtained by scanning the QR code
        on the Keycloak Required Action page. The server validates the token and returns a fresh
        nonce for proof-of-possession. On success, a pairing state keyed by the JWT `jti` is created.
      security:
        - pairingTokenAuth: [ ]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PairingInitRequest'
            examples:
              android:
                value:
                  deviceId: "android:3f24a1c2"
                  displayName: "Pixel 8 Pro"
                  publicKeyPem: |
                    -----BEGIN PUBLIC KEY-----
                    MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE...
                    -----END PUBLIC KEY-----
                  fcmToken: "fcm_token_example"
                  platform: ANDROID
                  osVersion: "14"
                  model: "Google Pixel 8 Pro"
                  attestation:
                    type: play-integrity
                    verdict: MEETS_DEVICE_INTEGRITY
      responses:
        '201':
          description: Pairing initiated; device must now confirm proof-of-possession.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PairingInitResponse'
              examples:
                ok:
                  value:
                    jti: "5b5c6a2f-2d3b-4c3b-8d8f-9f2e1e6f9c21"
                    nonce: "k6aB0u0cB4m0aP2O2nO5yA=="
                    exp: 1723712400
                    policy:
                      deviceLimitRemaining: 2
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '403': { $ref: '#/components/responses/Forbidden' }
        '409': { $ref: '#/components/responses/Conflict' }
        '422': { $ref: '#/components/responses/UnprocessableEntity' }
        '429': { $ref: '#/components/responses/TooManyRequests' }
        '500': { $ref: '#/components/responses/ServerError' }

  /pair/exchange/confirm:
    post:
      tags: [ Pairing ]
      summary: Confirm device pairing by proving possession of the generated private key.
      description: |
        The device signs the server-provided nonce and related context with its hardware-backed
        private key. On success, the orchestrator persists the device (e.g., writes a custom
        credential to Keycloak) and marks the `jti` state as `linked`.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PairingConfirmRequest'
            examples:
              confirm:
                value:
                  jti: "5b5c6a2f-2d3b-4c3b-8d8f-9f2e1e6f9c21"
                  deviceId: "android:3f24a1c2"
                  signature: "MEUCIE3..."  # base64url DER of ECDSA(SHA-256(nonce||jti||deviceId))
                  alg: ES256
      responses:
        '200':
          description: Pairing completed; device linked to user.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PairingConfirmResponse'
              examples:
                linked:
                  value:
                    status: linked
                    credential:
                      deviceId: "android:3f24a1c2"
                      displayName: "Pixel 8 Pro"
                      publicKeyPem: "-----BEGIN PUBLIC KEY-----..."
                      fcmToken: "fcm_token_example"
                      attestation:
                        type: play-integrity
                        verdict: MEETS_DEVICE_INTEGRITY
                      createdAt: 1723712000
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '403': { $ref: '#/components/responses/Forbidden' }
        '404': { $ref: '#/components/responses/NotFound' }
        '409': { $ref: '#/components/responses/Conflict' }
        '410': { $ref: '#/components/responses/Gone' }
        '422': { $ref: '#/components/responses/UnprocessableEntity' }
        '429': { $ref: '#/components/responses/TooManyRequests' }
        '500': { $ref: '#/components/responses/ServerError' }

  /pair/status/{jti}:
    get:
      tags: [ Pairing ]
      summary: Poll current pairing status.
      description: |
        Used by the Keycloak Required Action page (or app) to check whether the device
        has been successfully linked. This endpoint may be unauthenticated if the `jti`
        is sufficiently random; optionally require an `X-KC-Session` header bound to the
        Keycloak auth session.
      parameters:
        - $ref: '#/components/parameters/JtiParam'
        - in: header
          name: X-KC-Session
          required: false
          schema: { type: string }
          description: Optional binding to Keycloak `authSessionId`.
      responses:
        '200':
          description: Current state of the pairing operation.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PairingStatusResponse'
              examples:
                pending: { value: { state: pending } }
                linked: { value: { state: linked } }
                expired: { value: { state: expired } }
        '400': { $ref: '#/components/responses/BadRequest' }
        '404': { $ref: '#/components/responses/NotFound' }
        '410': { $ref: '#/components/responses/Gone' }
        '429': { $ref: '#/components/responses/TooManyRequests' }
        '500': { $ref: '#/components/responses/ServerError' }

  /challenge:
    post:
      tags: [ Challenge ]
      summary: Create a login-time ECG challenge and deliver FCM push.
      description: |
        Called by the Keycloak Authenticator (server-to-server). Creates a short-lived challenge,
        selects a target device, sends an FCM data message, and returns the challenge metadata.
      security:
        - serviceTokenAuth: [ ]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ChallengeCreateRequest'
            examples:
              create:
                value:
                  userId: "1a2b3c-user"
                  deviceId: "android:3f24a1c2"
                  ttlSeconds: 120
      responses:
        '201':
          description: Challenge created and push dispatched.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChallengeCreateResponse'
              examples:
                ok:
                  value:
                    challengeId: "79f1a833-2a0c-4af9-9d8a-8ff8121c98b2"
                    deviceId: "android:3f24a1c2"
                    nonce: "vxxP3w5F0Z4J9eN9oVY2BA=="
                    exp: 1723712460
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '403': { $ref: '#/components/responses/Forbidden' }
        '404': { $ref: '#/components/responses/NotFound' }
        '429': { $ref: '#/components/responses/TooManyRequests' }
        '500': { $ref: '#/components/responses/ServerError' }

  /challenge/{id}/status:
    get:
      tags: [ Challenge ]
      summary: Poll challenge status.
      description: |
        Used by the Keycloak login page to display live progress. This can be open to
        unauthenticated polling if the `id` is unguessable; alternatively require the
        `X-KC-Session` header.
      parameters:
        - $ref: '#/components/parameters/ChallengeIdParam'
        - in: header
          name: X-KC-Session
          required: false
          schema: { type: string }
          description: Optional binding to Keycloak `authSessionId`.
      responses:
        '200':
          description: Current state of the challenge.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChallengeStatusResponse'
              examples:
                pending: { value: { state: pending } }
                approved: { value: { state: approved } }
                denied: { value: { state: denied, reason: user_cancelled } }
                expired: { value: { state: expired } }
        '404': { $ref: '#/components/responses/NotFound' }
        '410': { $ref: '#/components/responses/Gone' }
        '429': { $ref: '#/components/responses/TooManyRequests' }
        '500': { $ref: '#/components/responses/ServerError' }

  /challenge/{id}/complete:
    post:
      tags: [ Challenge ]
      summary: Complete a challenge from the device after ECG pass and signature verification.
      description: |
        The mobile app posts a signed assertion to prove possession of the device key.
        The server validates signature (using the stored public key), nonce, and policy
        (e.g., biometric pass + score threshold). DPoP is recommended to bind the HTTP
        layer to the device key.
      security:
        - { }
      parameters:
        - $ref: '#/components/parameters/ChallengeIdParam'
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ChallengeCompleteRequest'
            examples:
              ok:
                value:
                  assertionJwt: "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJjaGFsbGVuZ2VJZCI6Ijc5ZjFhODMzLTI..."
                  matchScore: 0.94
                  biometricPassed: true
      responses:
        '200':
          description: Challenge outcome recorded.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChallengeStatusResponse'
              examples:
                approved: { value: { state: approved } }
                denied: { value: { state: denied, reason: low_score } }
        '400': { $ref: '#/components/responses/BadRequest' }
        '401': { $ref: '#/components/responses/Unauthorized' }
        '403': { $ref: '#/components/responses/Forbidden' }
        '404': { $ref: '#/components/responses/NotFound' }
        '409': { $ref: '#/components/responses/Conflict' }
        '410': { $ref: '#/components/responses/Gone' }
        '422': { $ref: '#/components/responses/UnprocessableEntity' }
        '429': { $ref: '#/components/responses/TooManyRequests' }
        '500': { $ref: '#/components/responses/ServerError' }

  /healthz:
    get:
      tags: [ Health ]
      summary: Liveness probe.
      responses:
        '200':
          description: Alive
          content:
            application/json:
              schema:
                type: object
                properties:
                  status: { type: string, enum: [ ok ] }
                  time: { type: string, format: date-time }

components:
  securitySchemes:
    pairingTokenAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: |
        Short-lived pairing token minted by Keycloak when rendering the QR. Audience should be `ecg-mobile-app`.
    serviceTokenAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
      description: |
        Server-to-server JWT from Keycloak Authenticator (service account). Use mTLS in addition for defense-in-depth.
    dpop:
      type: apiKey
      in: header
      name: DPoP
      description: Optional DPoP proof header (JWS) binding the HTTP request to the device key.

  parameters:
    JtiParam:
      name: jti
      in: path
      required: true
      description: One-time pairing token ID (UUID) from the QR's JWT `jti`.
      schema:
        type: string
        format: uuid
    ChallengeIdParam:
      name: id
      in: path
      required: true
      description: Challenge ID (UUID).
      schema:
        type: string
        format: uuid

  responses:
    BadRequest:
      description: Invalid input.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }
          examples:
            bad:
              value: { error: bad_request, message: "Malformed request body" }
    Unauthorized:
      description: Missing/invalid credentials.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }
          examples:
            unauth:
              value: { error: unauthorized, message: "Invalid or expired token" }
    Forbidden:
      description: Authenticated but not allowed to perform this action.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }
    NotFound:
      description: Resource not found.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }
    Conflict:
      description: Operation conflicts with current state (e.g., replay).
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }
    Gone:
      description: Resource no longer available (expired).
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }
    UnprocessableEntity:
      description: Semantically invalid (e.g., attestation failed, policy violation).
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }
    TooManyRequests:
      description: Rate limit exceeded.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }
    ServerError:
      description: Unexpected error.
      content:
        application/json:
          schema: { $ref: '#/components/schemas/Error' }

  schemas:
    PairingInitRequest:
      type: object
      required: [ deviceId, displayName, publicKeyPem, fcmToken, platform ]
      properties:
        deviceId:
          type: string
          description: Stable device identifier under your scheme.
          maxLength: 128
        displayName:
          type: string
          maxLength: 128
        publicKeyPem:
          type: string
          description: PEM-encoded P-256 public key generated in hardware-backed keystore.
        fcmToken:
          type: string
          description: Firebase Cloud Messaging token for the app instance.
        platform:
          type: string
          enum: [ ANDROID, IOS ]
        osVersion:
          type: string
          nullable: true
        model:
          type: string
          nullable: true
        attestation:
          $ref: '#/components/schemas/Attestation'
          description: Optional attestation evidence to evaluate device integrity.

    PairingInitResponse:
      type: object
      required: [ jti, nonce, exp ]
      properties:
        jti:
          type: string
          format: uuid
        nonce:
          type: string
          description: Base64 random 32-byte nonce to sign in confirm step.
        exp:
          type: integer
          format: int64
          description: Expiration time as UNIX epoch seconds.
        policy:
          type: object
          nullable: true
          properties:
            deviceLimitRemaining:
              type: integer
              minimum: 0

    PairingConfirmRequest:
      type: object
      required: [ jti, deviceId, signature, alg ]
      properties:
        jti:
          type: string
          format: uuid
        deviceId:
          type: string
        signature:
          type: string
          description: |
            Base64url-encoded DER ECDSA signature of SHA-256 over the byte-concatenation:
            `nonce || jti || deviceId`. The `nonce` is the raw bytes returned by init.
        alg:
          type: string
          enum: [ ES256 ]
        dpop:
          type: string
          nullable: true
          description: Optional DPoP JWS sent in the `DPoP` header.

    PairingConfirmResponse:
      type: object
      required: [ status ]
      properties:
        status:
          type: string
          enum: [ linked ]
        credential:
          $ref: '#/components/schemas/DeviceCredential'

    PairingStatusResponse:
      type: object
      required: [ state ]
      properties:
        state:
          type: string
          enum: [ pending, linked, expired, replayed, denied ]
        reason:
          type: string
          nullable: true
          description: Optional reason for terminal states.

    ChallengeCreateRequest:
      type: object
      required: [ userId ]
      properties:
        userId:
          type: string
          description: Keycloak user ID.
        deviceId:
          type: string
          nullable: true
          description: If omitted, orchestrator selects the best available device.
        ttlSeconds:
          type: integer
          minimum: 30
          maximum: 300
          default: 120

    ChallengeCreateResponse:
      type: object
      required: [ challengeId, deviceId, nonce, exp ]
      properties:
        challengeId:
          type: string
          format: uuid
        deviceId:
          type: string
        nonce:
          type: string
          description: Base64 random 32-byte nonce to be included in the device assertion.
        exp:
          type: integer
          format: int64

    ChallengeCompleteRequest:
      type: object
      required: [ assertionJwt ]
      properties:
        assertionJwt:
          type: string
          description: |
            JWS (ES256) signed by the device private key. Suggested payload claims:
            - `challengeId` (UUID), `nonce` (base64), `aud` ("ecg-mobile-app"), `iat`,
              `biometricPassed` (bool), `matchScore` (0..1), `deviceId`.
        matchScore:
          type: number
          minimum: 0
          maximum: 1
        biometricPassed:
          type: boolean

    ChallengeStatusResponse:
      type: object
      required: [ state ]
      properties:
        state:
          type: string
          enum: [ pending, approved, denied, expired ]
        reason:
          type: string
          nullable: true
          enum: [ low_score, user_cancelled, timeout, policy ]

    DeviceCredential:
      type: object
      required: [ deviceId, displayName, publicKeyPem, fcmToken, createdAt ]
      properties:
        deviceId: { type: string }
        displayName: { type: string }
        publicKeyPem: { type: string }
        fcmToken: { type: string }
        attestation: { $ref: '#/components/schemas/Attestation' }
        createdAt:
          type: integer
          format: int64

    Attestation:
      type: object
      description: Generic envelope for platform attestation.
      properties:
        type:
          type: string
          enum: [ play-integrity, safety-net, devicecheck, none ]
        verdict:
          type: string
          nullable: true
        payload:
          type: object
          nullable: true
          additionalProperties: true

    Error:
      type: object
      required: [ error, message ]
      properties:
        error:
          type: string
          description: Machine-readable error code (snake_case).
        message:
          type: string
          description: Human-readable message.
        details:
          type: object
          nullable: true
          additionalProperties: true
